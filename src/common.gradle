/**
 * Copyright (c) 2023. Cellpoint Digital
 * www.cellpointdigital.com
 *
 */
import org.apache.tools.ant.filters.ReplaceTokens

import java.time.*
import java.time.format.DateTimeFormatter
import java.util.regex.*

if (findProperty('addonsPath') == null) {
    throw new GradleException('"addonsPath" property is not configured, please add: ext.addonsPath = "${projectDir}/addons/src";  to your root build.gradle file.')
}

ext {
    def now = OffsetDateTime.now(ZoneOffset.UTC)
    timestamp = now // assign ext.timestamp

    // This function will apply build configurations required for java based project.
    useJavaFeatures = { Project p, Map<String, Object> config = [:] ->
        if (!p.plugins.hasPlugin('java')) {
            throw new GradleException("useJavaFeatures() can be used in project with 'java' plugin connected.")
        }

        def javaVersion = (config.javaVersion ?: JavaVersion.current()) as JavaVersion

        // takes file from root/gradle, if not exists it takes common file
        def applyIfExists = name -> {
            File overriding = p.file('gradle/' + name + '.gradle')
            if (overriding.exists()) {
                p.apply([from: overriding])
            } else {
                File overridingRoot = p.rootProject.file('gradle/' + name + '.gradle')
                if (p != p.rootProject && overridingRoot.exists()) {
                    p.apply([from: overridingRoot])
                } else {
                    File addon = p.rootProject.file(p.property('addonsPath') + '/' + name + '.gradle')
                    if (addon.exists() && !Boolean.FALSE.equals(config.get(name))) {
                        p.apply([from: addon])
                    }
                }
            }
        }

        applyIfExists('repositories')
        applyIfExists('dependencies')
        applyIfExists('test')
        applyIfExists('spotbugs')
        applyIfExists('jacoco')

        p.compileJava.options.encoding = "UTF-8"
        p.compileTestJava.options.encoding = "UTF-8"
        p.java {
            sourceCompatibility = javaVersion
            targetCompatibility = javaVersion
        }

        if (p.plugins.hasPlugin('org.springframework.boot')) {
            p.configurations {
                compileOnly {
                    extendsFrom annotationProcessor
                }
            }

            p.bootJar {
                archiveFileName = 'server.jar'
            }
        }


        // calculate effective build version
        def runNumber = ext.has('runNumber') ? ext.get('runNumber') : System.getenv('GITHUB_RUN_NUMBER')
        def semver = prepareSemver(version, ext.gitDetails, ext.branchName, runNumber, now)
        println("The effective version of the application is '$semver'.")
        ext.buildSemver = semver

        // replace tokens @build.version@, @build.semver@ and @build.timestamp@
        if (!Boolean.FALSE.equals(config.get('processJavaResources'))) {
            p.processResources {
                filesMatching(['**/*.properties', '**/*.yaml']) {
                    filter(ReplaceTokens, tokens: [
                            'build.version'  : p.version,
                            'build.semver'   : semver,
                            'build.timestamp': now.toString() // UTC build time example: 2023-10-15T21:19:24.095308270Z
                    ])
                }
            }
        }

    }

}

/**
 * Create semver2 compatible string X.Y.Z[.R][-name]+[GIT_SHA-]yyMMddHHmm
 *
 * @param ver version of project (contains X.Y.0-*)
 * @param git a map containing
 *     .branchName (release/Nuuk, feature/CPD-NNNN-*, feature/CPD-NNNN-yyMMddHHmm )
 *     .tags used for tags that can be sha-xxxxx, X.Y.Z-*
 *     .sha
 * @param branch an effective branch name
 * @param runNumber CI run number
 * @return not null string
 */
private static String prepareSemver(String ver, Map<String, String> git, String branch, String runNumber,
                                    OffsetDateTime now) {
    git = git ?: [:] // use empty map by default
    // find X.Y.Z part from several sources
    def tags = (git.tags ?: '').tokenize(',')
    def cases = tags + [branch, ver]
    def pattern = ~/^(v|v\.)?(\d+(\.\d+){2})($|[-_.].+$)/
    def result = cases.stream().filter(s -> s != null)
            .map(pattern::matcher).filter(Matcher::find).map(m -> m.group(2)).findFirst()
            .orElseThrow(() -> new GradleException("Cannot determine the app version! You need set project version or add GIT tag in format 'X.Y.Z'."))

    // adding run number as 4th part
    if (runNumber?.isNumber()) {
        result += '.' + runNumber
    }

    // find name part from several sources
    def pattern1 = ~/((v|v\.)?(\d+(\.\d+){2,3}))/
    def pattern2 = ~/^[-\s]*(.+)[-\s]*$/
    def names = [branch] + (git.tags ?: '').tokenize(',')
    def name = names.stream().map(s -> extractName(s,pattern1, pattern2))
            .filter(s -> s != null && s.length() > 3).findFirst().orElse('')
    if (!name.isEmpty()) {
        result += '-' + name;
    }

    // add build-part
    def buildTime = DateTimeFormatter.ofPattern('yyMMddHHmm').format(now)
    result += '+' + (git.sha == null ? '' : git.sha + '-') + buildTime
    return result.toLowerCase()
}

private static String extractName(String branchOrTagName, Pattern pattern1, Pattern pattern2) {
    if (branchOrTagName == null || branchOrTagName.isBlank()) {
        return null
    }
    def last = branchOrTagName.lastIndexOf('/')
    def s = branchOrTagName.substring(last + 1)
    s = pattern1.matcher(s).replaceAll('')
    def matcher = pattern2.matcher(s)
    if (!matcher.find()) {
        return null;
    }
    return matcher.group(1)
}
